# Copyright 2013 Tom Noonan II (TJNII)
# 
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
# 
#     http://www.apache.org/licenses/LICENSE-2.0
# 
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
# See the License for the specific language governing permissions and
# limitations under the License.
# 
require 'rest_client'
require 'json'
require 'ipaddr'

# getNodeIPs: Query the puppetDB inventory API for a given zone
# (Zone data generated by custom facter facts) and return the IPv4
# and/or IPv6 address of the first zone interface
#
# PRE: None
# POST: None
# RETURN VALUE: Returns a hash of hashes with IP data
def getNodeIPs(zone, dbhost = "localhost:8080")
  nodes=JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes", {:accept => :json}))

  retVal = Hash.new
  nodes.each do |node|
    nodename = node["name"]
    interfacedata = JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes/#{nodename}/facts/interfaces_#{zone}", {:accept => :json}))
    if interfacedata[0] != nil
      # Only use the first interface for auto generated records
      interface = interfacedata[0]["value"].split(",")[0]

      ipv4 = JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes/#{nodename}/facts/ipaddress_#{interface}", {:accept => :json}))
      if ipv4[0] != nil
        if !retVal.has_key?(nodename)
          retVal[nodename] = Hash.new
        end

        retVal[nodename]["ipv4"] = ipv4[0]["value"]
      end

      ipv6 = JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes/#{nodename}/facts/ipaddress6_#{interface}", {:accept => :json}))
      if ipv6[0] != nil
        if !retVal.has_key?(nodename)
        retVal[nodename] = Hash.new
        end

        retVal[nodename]["ipv6"] = ipv6[0]["value"]
      end
    end
  end

  return retVal
end


# getAllNodeIPsBySubnet: Query the puppetDB inventory API for all nodes                                                                                                                                                       
# and return a list of all the IPs for the node in the given subnet                                                                                                                                                           
# Intended for rDNS generation                                                                                                                                                                                                
#                                                                                                                                                                                                                             
# Currently only handles IPv4                                                                                                                                                                                                 
#                                                                                                                                                                                                                             
# PRE: None                                                                                                                                                                                                                   
# POST: None                                                                                                                                                                                                                  
# RETURN VALUE: Returns a hash of hashes with IP data                                                                                                                                                                         
def getAllNodeIPsBySubnet(network, netmask, dbhost = "localhost:8080")
  maskint = IPAddr.new(netmask).to_i
  netint = IPAddr.new(network).to_i & maskint

  nodes=JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes", {:accept => :json}))

  retVal = Hash.new
  nodes.each do |node|
    nodename = node["name"]

    interfacedata = JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes/#{nodename}/facts/interfaces", {:accept => :json}))
    if interfacedata[0] != nil
      # Only use the first interface for auto generated records
      interfacedata[0]["value"].split(",").each do |interface|

        if interface == "lo"
          next
        end
        
        ipv4 = JSON.parse(RestClient.get("http://#{dbhost}/v2/nodes/#{nodename}/facts/ipaddress_#{interface}", {:accept => :json}))
        if ipv4[0] != nil
          if (IPAddr.new(ipv4[0]["value"]).to_i & maskint) == netint
            if !retVal.has_key?(nodename)
              retVal[nodename] = Array.new
            end
            
            retVal[nodename].push(ipv4[0]["value"])
          end
        end
      
      end
    end
  end
  
  return retVal
end

# getExportedKeys(): Get a list of key files exported to the master
# PRE: None
# POST: None
# RETURN VALUE: Returns an array or fully qualified filenames
def getExportedKeys(nodename, view)
  return getResourceList(nodename, "^exported \/etc\/bind\/keys\/.+\.#{view}\.key$").map{|s| s.sub(/^exported /, '')}
end

# getSlaveCOnfigs(): Get a list of /etc/bind/conf.d/*.conf files
# PRE: None
# POST: None
# RETURN VALUE: Returns an array or fully qualified filenames
def getSlaveConfigs(nodename)
  return getResourceList(nodename, '^\/etc\/bind\/conf\.d\/.*\.conf$')
end


# getResourceList(): Get a list of resources matching regex
# PRE: None
# POST: None
# RETURN VALUE: Returns an array or fully qualified filenames
def getResourceList(nodename, regex)
  nodename = nodename.downcase

  resources=JSON.parse(RestClient.get("http://localhost:8080/v2/nodes/#{nodename}/resources", {:accept => :json}))
  
  retVal = Array.new

  resources.each do |resource|
    if resource["title"] =~ /#{regex}/
      retVal.push(resource["title"])
    end
  end

  return retVal
end

# getSlaveKeyViews(): Get a list of views which have local keys
# PRE: None
# POST: None
# RETURN VALUE: Returns an array or fully qualified filenames
def getSlaveKeyViews(nodename)
  return getResourceList(nodename, "^local \/etc\/bind\/keys\/.+\.[^\.]+\.key$").map{|s| s.sub(/^local \/etc\/bind\/keys\/.+\.([^\.]+)\.key$/, '\1')}
end


# getSlaveNameFromKeyName(): Extract slave hostname from key filename
# PRE: Filename is of the form "/etc/bind/keys/#{hostname}.#{view}.key" (Anchored)
# POST: None
# RETURN VALUE: Returns the FQDN on success or nil on error
def getSlaveNameFromKeyName(filename)
  if filename =~ /^\/etc\/bind\/keys\/.+\.[^\.]+\.key$/
    return filename.sub(/^\/etc\/bind\/keys\/(.+)\.[^\.]+\.key$/, '\1')
  else
    return nil
  end
end

# makeKeyID: Make a bind key identifier string from the hostname and view.
#   Entended to ensure consistent naming between master and slaves
# PRE: none
# POST: None
# RETURN VALUE: ID string
def makeKeyID(hostname, view)
  return "#{view}-#{hostname}."
end

def getServerInternalIP(hostname)
  hostname = hostname.downcase
  ipData = JSON.parse(RestClient.get("http://localhost:8080/v2/nodes/#{hostname}/facts/ipaddress_internal", {:accept => :json}))
  if ipData[0] != nil 
    return ipData[0]["value"]
  else
    # There is a corner case where the slave hostname will be overridden to not match the hostname used in puppetdb
    # Try DNS if puppetdb lookup fails
    require "resolv"
    begin
      # This throws an exception on no match
      ipaddr = Resolv.getaddress hostname
    rescue
      return nil
    end
    return ipaddr
  end
end

# getViewNameservers: Generate a list of nameservers for a zone
# Sources names from the keys on the master
# Returns nodename if no keys exported
# PRE: nodename is the master FQDN
# POST: None
# RETURN VALUE: A list of nameserver hostnames
def getViewNameservers(nodename, view)
  keys = getExportedKeys(nodename, view)
  if keys.length < 1
    return [getServerInternalIP(nodename)]
  end
  
  retval = keys.map{|k| getSlaveNameFromKeyName(k) }
  return retval.sort
end
